# SpotifyAwesomePlaylist

# Введение
Spotify обладает достаточно большой библиотекой музыки, однако в части рекомендаций достаточно часто предлагает треки которые уже были прослушаны, или плейлисты которые не очень соответствуют ожиданиям. Другим ограничивающим фактором является то, что при пользовании Spotify приходится ориентироваться на алгоритмы, которые в нём реализованы без возможности как-то осознанно влиять на их поведение.

Алгоритм в основном направлен на генерацию плейлистов для тренировок. Тестирование на треках жанров Drum & Bass и Psy Trance.

# Пререквизиты
Проект основан на [Goofy](https://chimildic.github.io/goofy/#/), поэтому для использования необходимо будет выполнить предварительные шаги по установке и настройке

# Цель
Формирование плейлиста(листов) в соответствии с потребностями с возможностью настройки параметров и обратной связью

# Основная идея

* Выбрать несколько треков в качестве отправной точки (до 5, это ограничение Spotify для рекомендаций) - желательно выбрать треки одного жанра и в целом имеющие сходство, хотя это не точно, как работает рекомендательный алгоритм я не знаю
* Посмотреть технические параметры выбранных треков для настройки генерации плейлистов (bpm, мелодичность, многословность, энергичность) - [подробнее о параметрах](https://chimildic.github.io/goofy/#/reference/desc?id=%d0%9e%d1%81%d0%be%d0%b1%d0%b5%d0%bd%d0%bd%d0%be%d1%81%d1%82%d0%b8-%d1%82%d1%80%d0%b5%d0%ba%d0%b0-features)
* На основе рекомендаций сформировать плейлист
* *Слушать его и ставить лайки* - наверное самая важная часть всей схемы

## Обратная связь
После первой генерации плейлиста необходимо обеспечить использование обратной связи, т.е. адаптировать алгоритм к тому, насколько результат соответствует ожиданиям

* Посмотреть сколько лайков набрал сформированный плейлист
* Взять до 5 элементов в качестве исходного массива для генерации новой версии плейлиста
  * запомнить лайки (накопительным итогом, т.е. история по лайкам будет накапливаться только для этого плейлиста отдельно)
  * сделать часть плейлиста на основе лайков из последнего плейлиста
  * если остались не прослушанные треки, то дать части из них второй шанс (*отключаемо*)
* отдельно запомнить то, где лайков не было (*т.е. прослушанный плейлист разделяется на две части - где были лайки и где не было. Соответственно то, что прослушано и не набрало лайков позже можно будет отфильтровать, что бы избежать повторов*)
* Взять из истории (произвольно) до 5 элементов в качестве исходного массива для генерации новой версии плейлиста (*т.е. то, где был лайк в предыдущие дни*)
  * получить рекомендации по ним
  * удалить то, что было прослушано в предыдущие дни
  * удалить то, где были лайки за предыдущие дни - *больше приоритет новой музыки*
* Склеить вместе плейлист из трёх частей:
  * рекомендациии на основании того, что понравилось в последний раз (*условно - вчера*)
  * рекомендациии на основании того, что понравилось в другие дни __только из этого плейлиста__
  * часть из того, что не было прослушано в предыдущие дни
* Если не хватает времени прослушать плейлист целиком, то укоротить его до требуемой длины (*по умолчанию - длина рекомендации 100, длина плейлиста для "второго шанса" - 25% от непрослушанных треков*) - по умолчанию 50

## Настройка
### Полный сброс
Можно удалить сгенерированный плейлист, в этом случае так же удаляется весь кэш статистики за предыдущие дни, и весь процесс начинается с начала

### Настройка параметров
Настройка параметров необходима на основе ваших предпочтений. Поддерживаемые параметры:
* needBlender - использовать не только лайки из последнего плейлиста, но так же из предыдущих прослушиваний
* secondChance - давать второй шанс трекам которые не были прослушаны ранее
* secondChancePerc - количество треков в процентах для второго шанса
* makePublic - делать плейлист публичным
* minTempo - минимальный темп (BPM)
* minDancability - минимальная "танцевальность"
* minEnergy - минимальная энергичность

## Расширение
Основная идея в том, что бы генерация плейлистов была независимой. Под каждый набор исходных данных можно сформировать отдельный набор значений путём копирования функции genTrancePlaylist() и изменения параметров.
